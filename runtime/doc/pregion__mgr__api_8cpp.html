<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Atlas Runtime: src/pregion_mgr/pregion_mgr_api.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Atlas Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pregion__mgr__api_8cpp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pregion_mgr_api.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="atlas__alloc_8h_source.html">atlas_alloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="atlas__alloc__cpp_8hpp_source.html">atlas_alloc_cpp.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pregion__mgr_8hpp_source.html">pregion_mgr.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pregion_mgr_api.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="pregion__mgr__api_8cpp__incl.png" border="0" usemap="#src_2pregion__mgr_2pregion__mgr__api_8cpp" alt=""/></div>
<map name="src_2pregion__mgr_2pregion__mgr__api_8cpp" id="src_2pregion__mgr_2pregion__mgr__api_8cpp">
<area shape="rect" id="node2" href="atlas__alloc_8h.html" title="atlas_alloc.h" alt="" coords="5,319,100,345"/>
<area shape="rect" id="node6" href="atlas__alloc__cpp_8hpp.html" title="atlas_alloc_cpp.hpp" alt="" coords="840,95,977,121"/>
<area shape="rect" id="node7" href="pregion__mgr_8hpp.html" title="pregion_mgr.hpp" alt="" coords="697,95,816,121"/>
<area shape="rect" id="node14" href="pregion__configs_8hpp.html" title="pregion_configs.hpp" alt="" coords="786,319,925,345"/>
<area shape="rect" id="node15" href="pregion__mgr__util_8hpp.html" title="pregion_mgr_util.hpp" alt="" coords="685,169,828,196"/>
<area shape="rect" id="node17" href="pregion_8hpp.html" title="pregion.hpp" alt="" coords="379,169,468,196"/>
<area shape="rect" id="node19" href="atlas__api_8h.html" title="atlas_api.h" alt="" coords="409,319,494,345"/>
<area shape="rect" id="node20" href="internal__api_8h.html" title="internal_api.h" alt="" coords="242,244,341,271"/>
<area shape="rect" id="node21" href="pmalloc_8hpp.html" title="pmalloc.hpp" alt="" coords="557,244,649,271"/>
<area shape="rect" id="node23" href="pmalloc__util_8hpp.html" title="pmalloc_util.hpp" alt="" coords="365,244,481,271"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aefba19b4d9636e1ef78ae8e85b54883c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#aefba19b4d9636e1ef78ae8e85b54883c">NVM_FindOrCreateRegion</a> (const char *name, int flags, int *is_created)</td></tr>
<tr class="memdesc:aefba19b4d9636e1ef78ae8e85b54883c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a persistent region with the provided name.  <a href="#aefba19b4d9636e1ef78ae8e85b54883c">More...</a><br /></td></tr>
<tr class="separator:aefba19b4d9636e1ef78ae8e85b54883c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f92aa79e4f6583db69ce7314fbacdd3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a5f92aa79e4f6583db69ce7314fbacdd3">NVM_FindRegion</a> (const char *name, int flags)</td></tr>
<tr class="memdesc:a5f92aa79e4f6583db69ce7314fbacdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the id of a region when it is known to exist already.  <a href="#a5f92aa79e4f6583db69ce7314fbacdd3">More...</a><br /></td></tr>
<tr class="separator:a5f92aa79e4f6583db69ce7314fbacdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e86fc1cc4b8141b990627df6eeaf68"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#ac4e86fc1cc4b8141b990627df6eeaf68">NVM_CreateRegion</a> (const char *name, int flags)</td></tr>
<tr class="memdesc:ac4e86fc1cc4b8141b990627df6eeaf68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a named persistent region.  <a href="#ac4e86fc1cc4b8141b990627df6eeaf68">More...</a><br /></td></tr>
<tr class="separator:ac4e86fc1cc4b8141b990627df6eeaf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a7d54a9cac9e274ad3c49b452a187c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#ab2a7d54a9cac9e274ad3c49b452a187c">NVM_CloseRegion</a> (uint32_t rid)</td></tr>
<tr class="memdesc:ab2a7d54a9cac9e274ad3c49b452a187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a persistent region.  <a href="#ab2a7d54a9cac9e274ad3c49b452a187c">More...</a><br /></td></tr>
<tr class="separator:ab2a7d54a9cac9e274ad3c49b452a187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8046db8a20fa43ba3dabe6c40842024c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a8046db8a20fa43ba3dabe6c40842024c">NVM_DeleteRegion</a> (const char *name)</td></tr>
<tr class="memdesc:a8046db8a20fa43ba3dabe6c40842024c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the region with the provided name.  <a href="#a8046db8a20fa43ba3dabe6c40842024c">More...</a><br /></td></tr>
<tr class="separator:a8046db8a20fa43ba3dabe6c40842024c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce292e947bc31b2da5140266451059a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a4ce292e947bc31b2da5140266451059a">NVM_GetRegionRoot</a> (uint32_t rid)</td></tr>
<tr class="memdesc:a4ce292e947bc31b2da5140266451059a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the root pointer of the persistent region.  <a href="#a4ce292e947bc31b2da5140266451059a">More...</a><br /></td></tr>
<tr class="separator:a4ce292e947bc31b2da5140266451059a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d2b2d7249490fc2dd3f0ce5c6ab390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a26d2b2d7249490fc2dd3f0ce5c6ab390">NVM_SetRegionRoot</a> (uint32_t rid, void *new_root)</td></tr>
<tr class="memdesc:a26d2b2d7249490fc2dd3f0ce5c6ab390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root pointer of an existing persistent region.  <a href="#a26d2b2d7249490fc2dd3f0ce5c6ab390">More...</a><br /></td></tr>
<tr class="separator:a26d2b2d7249490fc2dd3f0ce5c6ab390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb53331e3dfc859dcc887bc3dfa743"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a24fb53331e3dfc859dcc887bc3dfa743">nvm_alloc</a> (size_t sz, uint32_t rid)</td></tr>
<tr class="memdesc:a24fb53331e3dfc859dcc887bc3dfa743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Malloc style interface for allocation from a persistent region.  <a href="#a24fb53331e3dfc859dcc887bc3dfa743">More...</a><br /></td></tr>
<tr class="separator:a24fb53331e3dfc859dcc887bc3dfa743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ab280ca5acf9422d9ca0dfb281883"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a385ab280ca5acf9422d9ca0dfb281883">nvm_calloc</a> (size_t nmemb, size_t sz, uint32_t rid)</td></tr>
<tr class="memdesc:a385ab280ca5acf9422d9ca0dfb281883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calloc style interface for allocation from a persistent region.  <a href="#a385ab280ca5acf9422d9ca0dfb281883">More...</a><br /></td></tr>
<tr class="separator:a385ab280ca5acf9422d9ca0dfb281883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fa3df11470580d1afde4e51322c362"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#ae9fa3df11470580d1afde4e51322c362">nvm_realloc</a> (void *ptr, size_t sz, uint32_t rid)</td></tr>
<tr class="memdesc:ae9fa3df11470580d1afde4e51322c362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realloc style interface for allocation from a persistent region.  <a href="#ae9fa3df11470580d1afde4e51322c362">More...</a><br /></td></tr>
<tr class="separator:ae9fa3df11470580d1afde4e51322c362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38accce7e02425b94bdd21fcc9459f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#aa38accce7e02425b94bdd21fcc9459f9">nvm_free</a> (void *ptr)</td></tr>
<tr class="memdesc:aa38accce7e02425b94bdd21fcc9459f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocation interface for persistent data.  <a href="#aa38accce7e02425b94bdd21fcc9459f9">More...</a><br /></td></tr>
<tr class="separator:aa38accce7e02425b94bdd21fcc9459f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28aa123fdfcddf1d450ecba95d5a1c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a28aa123fdfcddf1d450ecba95d5a1c5d">nvm_delete</a> (void *ptr)</td></tr>
<tr class="separator:a28aa123fdfcddf1d450ecba95d5a1c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c4640294c93a9c3e205bf2ca575a91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a64c4640294c93a9c3e205bf2ca575a91">NVM_IsInOpenPR</a> (void *addr, size_t sz)</td></tr>
<tr class="separator:a64c4640294c93a9c3e205bf2ca575a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff92ce8cbc07ee4c3dfb3b536a8d2b55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#aff92ce8cbc07ee4c3dfb3b536a8d2b55">isOnDifferentCacheLine</a> (void *p1, void *p2)</td></tr>
<tr class="memdesc:aff92ce8cbc07ee4c3dfb3b536a8d2b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the addresses are on different cache lines.  <a href="#aff92ce8cbc07ee4c3dfb3b536a8d2b55">More...</a><br /></td></tr>
<tr class="separator:aff92ce8cbc07ee4c3dfb3b536a8d2b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade061701d823b2f58bc3bf3ceaae04fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#ade061701d823b2f58bc3bf3ceaae04fa">isCacheLineAligned</a> (void *p)</td></tr>
<tr class="memdesc:ade061701d823b2f58bc3bf3ceaae04fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a memory location is aligned to a cache line.  <a href="#ade061701d823b2f58bc3bf3ceaae04fa">More...</a><br /></td></tr>
<tr class="separator:ade061701d823b2f58bc3bf3ceaae04fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6724e1078ed70514f1f7e458814bc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#aed6724e1078ed70514f1f7e458814bc6">NVM_IsInRegion</a> (void *ptr, size_t sz)</td></tr>
<tr class="memdesc:aed6724e1078ed70514f1f7e458814bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a memory location is within a region.  <a href="#aed6724e1078ed70514f1f7e458814bc6">More...</a><br /></td></tr>
<tr class="separator:aed6724e1078ed70514f1f7e458814bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d6bd8599345af8c09610cb9efbcb8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAtlas_1_1PRegion.html">PRegion</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#ac1d6bd8599345af8c09610cb9efbcb8f">NVM_GetRegion</a> (uint32_t rid)</td></tr>
<tr class="memdesc:ac1d6bd8599345af8c09610cb9efbcb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a persistent region.  <a href="#ac1d6bd8599345af8c09610cb9efbcb8f">More...</a><br /></td></tr>
<tr class="separator:ac1d6bd8599345af8c09610cb9efbcb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049435b44f803e4ad20ec957bccfa5f5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a049435b44f803e4ad20ec957bccfa5f5">operator new</a> (size_t sz, <a class="el" href="classAtlas_1_1PRegion.html">Atlas::PRegion</a> *rgn) noexcept</td></tr>
<tr class="memdesc:a049435b44f803e4ad20ec957bccfa5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object allocation for C++.  <a href="#a049435b44f803e4ad20ec957bccfa5f5">More...</a><br /></td></tr>
<tr class="separator:a049435b44f803e4ad20ec957bccfa5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c42585515f88d749ebb4f87681c5d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pregion__mgr__api_8cpp.html#a7b9c42585515f88d749ebb4f87681c5d">operator new[]</a> (size_t sz, <a class="el" href="classAtlas_1_1PRegion.html">Atlas::PRegion</a> *rgn) noexcept</td></tr>
<tr class="memdesc:a7b9c42585515f88d749ebb4f87681c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array form allocation for C++, type must have explicit destructor.  <a href="#a7b9c42585515f88d749ebb4f87681c5d">More...</a><br /></td></tr>
<tr class="separator:a7b9c42585515f88d749ebb4f87681c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ade061701d823b2f58bc3bf3ceaae04fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isCacheLineAligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a memory location is aligned to a cache line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Address of memory location under consideration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether the memory location is cache line aligned </dd></dl>

</div>
</div>
<a class="anchor" id="aff92ce8cbc07ee4c3dfb3b536a8d2b55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isOnDifferentCacheLine </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the addresses are on different cache lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>First address </td></tr>
    <tr><td class="paramname">p2</td><td>Second address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Indicates whether the addresses are on different cache lines</dd></dl>
<p>The objects under consideration must not cross cache lines, otherwise this interface is inadequate. </p>

</div>
</div>
<a class="anchor" id="a24fb53331e3dfc859dcc887bc3dfa743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvm_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Malloc style interface for allocation from a persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Size of location to be allocated </td></tr>
    <tr><td class="paramname">rid</td><td>Id of persistent region for allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of memory location allocated </dd></dl>

</div>
</div>
<a class="anchor" id="a385ab280ca5acf9422d9ca0dfb281883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvm_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calloc style interface for allocation from a persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nmemb</td><td>Number of elements in the array to be allocated </td></tr>
    <tr><td class="paramname">sz</td><td>Size of each element </td></tr>
    <tr><td class="paramname">rid</td><td>Id of persistent region for allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to allocated memory </dd></dl>

</div>
</div>
<a class="anchor" id="ab2a7d54a9cac9e274ad3c49b452a187c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NVM_CloseRegion </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rid</td><td>Region id</td></tr>
  </table>
  </dd>
</dl>
<p>After closing, it won't be available to the calling process without calling NVM_FindOrCreateRegion. The region will stay in NVM even after calling this interface. This interface allows closing a region with normal bookkeeping. </p>

</div>
</div>
<a class="anchor" id="ac4e86fc1cc4b8141b990627df6eeaf68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NVM_CreateRegion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a named persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the persistent region </td></tr>
    <tr><td class="paramname">flags</td><td>access flag (one of O_RDONLY, O_WRONLY, O_RDWR) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the region created</dd></dl>
<p>This interface does not check for an existing entry with the same name. If a region with the same name already exists, the behavior of the program is undefined. </p>

</div>
</div>
<a class="anchor" id="a28aa123fdfcddf1d450ecba95d5a1c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8046db8a20fa43ba3dabe6c40842024c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NVM_DeleteRegion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the region with the provided name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the persistent region</td></tr>
  </table>
  </dd>
</dl>
<p>Use this interface to completely destroy a region. If the region does not exist, an assertion failure will occur. </p>

</div>
</div>
<a class="anchor" id="aefba19b4d9636e1ef78ae8e85b54883c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NVM_FindOrCreateRegion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>is_created</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a persistent region with the provided name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the persistent region </td></tr>
    <tr><td class="paramname">flags</td><td>access flag (one of O_RDONLY, O_WRONLY, O_RDWR) </td></tr>
    <tr><td class="paramname">is_created</td><td>Indicator whether the region got created as a result of the call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the region found or created</dd></dl>
<p>If the region already exists, the existing id of the region is returned. Otherwise a region is created and its newly assigned id returned. </p>

</div>
</div>
<a class="anchor" id="a5f92aa79e4f6583db69ce7314fbacdd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t NVM_FindRegion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the id of a region when it is known to exist already. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the persistent region </td></tr>
    <tr><td class="paramname">flags</td><td>access flag (one of O_RDONLY, O_WRONLY, O_RDWR) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the region found</dd></dl>
<p>This interface should be used over NVM_FindOrCreateRegion for efficiency reasons if the region is known to exist. If a region with the provided name does not exist, an assertion failure will occur. </p>

</div>
</div>
<a class="anchor" id="aa38accce7e02425b94bdd21fcc9459f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvm_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocation interface for persistent data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Address of memory location to be freed.</td></tr>
  </table>
  </dd>
</dl>
<p>Though the usual use case would be for the location to be in persistent memory, this interface will also work for transient data. The implementation is required to transparently handle this case as well. </p>

</div>
</div>
<a class="anchor" id="ac1d6bd8599345af8c09610cb9efbcb8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAtlas_1_1PRegion.html">PRegion</a>* NVM_GetRegion </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to a persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rid</td><td>Region identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the corresponding persistent region</dd></dl>
<p>Currently, this interface is to be used by a client only for the placement new operations </p>

</div>
</div>
<a class="anchor" id="a4ce292e947bc31b2da5140266451059a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* NVM_GetRegionRoot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the root pointer of the persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rid</td><td>Region id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Root pointer of the region</dd></dl>
<p>The region must have been created already. Currently, only one root is implemented for a given region. The idea is that anything within a region that is not reachable from the root after program termination is assumed to be garbage and can be recycled. During execution, anything within a region that is not reachable from the root or from other <em>roots</em> (in the GC sense) is assumed to be garbage as well. </p>

</div>
</div>
<a class="anchor" id="a64c4640294c93a9c3e205bf2ca575a91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVM_IsInOpenPR </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the following address with associated size within an open persistent region? </p>

</div>
</div>
<a class="anchor" id="aed6724e1078ed70514f1f7e458814bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NVM_IsInRegion </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if a memory location is within a region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Queried address </td></tr>
    <tr><td class="paramname">sz</td><td>Size of the location in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if within the region, otherwise 0 </dd></dl>

</div>
</div>
<a class="anchor" id="ae9fa3df11470580d1afde4e51322c362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nvm_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Realloc style interface for allocation from a persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Address of memory block provided </td></tr>
    <tr><td class="paramname">sz</td><td>New size of allocation </td></tr>
    <tr><td class="paramname">rid</td><td>Id of persistent region for allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to re-allocated memory </dd></dl>

</div>
</div>
<a class="anchor" id="a26d2b2d7249490fc2dd3f0ce5c6ab390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NVM_SetRegionRoot </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the root pointer of an existing persistent region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rid</td><td>Region id </td></tr>
    <tr><td class="paramname">root</td><td>The new root of the region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a049435b44f803e4ad20ec957bccfa5f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtlas_1_1PRegion.html">Atlas::PRegion</a> *&#160;</td>
          <td class="paramname"><em>rgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Object allocation for C++. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Allocation size </td></tr>
    <tr><td class="paramname">rgn</td><td>Pointer to the region to serve the allocation from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory allocated</dd></dl>
<p>This interface overloads the C++ placement new operator. The corresponding delete operation is NVM_Destroy. </p>

</div>
</div>
<a class="anchor" id="a7b9c42585515f88d749ebb4f87681c5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAtlas_1_1PRegion.html">Atlas::PRegion</a> *&#160;</td>
          <td class="paramname"><em>rgn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array form allocation for C++, type must have explicit destructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sz</td><td>Allocation size </td></tr>
    <tr><td class="paramname">rgn</td><td>Pointer to the region to serve the allocation from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to memory allocated</dd></dl>
<p>This interface overloads the array form C++ placement new operator. The type of the array elements must have an explicit destructor. The corresponding delete operation is NVM_Destroy_Array. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_6410d95d1dc0cfc4db344ef79b02b8be.html">pregion_mgr</a></li><li class="navelem"><a class="el" href="pregion__mgr__api_8cpp.html">pregion_mgr_api.cpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
